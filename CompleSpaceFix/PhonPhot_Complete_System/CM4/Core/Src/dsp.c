/*
 * dsp.c
 *
 *  Created on: Jan 26, 2022
 *      Author: Mason
 */

// TODO - Set interrupt priorities correctly

/* Peripherals
 *
 * ADC1, 3 inputs for microphone signals
 * ADC3, 3 inputs for microphone signals
 *
 * DMA1_Stream0 -> P2M, ADC1 data out
 * DMA1_Stream1 -> P2M, ADC3 data out
 *
 * DMA1_Stream7 -> USART3 TX data
 *
 */

/* Interrupts
 *
 * DMA1_Stream1 half transfer, transfer complete (ADC3)
 */

// define for math library
#define ARM_MATH_CM4

// Comment out FFT_AVERAGING define to use only instantaneous FFT data for detection
#define FFT_AVERAGING
// Comment out FFT_WINDOWING define to use rectangular window
#define FFT_WINDOWING

// "current data" is actually an average of the n past data
#ifdef FFT_AVERAGING
#define FFT_AVERAGE_SAMPLES 8
#endif

// number of channels for each adc
#define ADC1_CHANNELS 3
#define ADC3_CHANNELS 3
#define ADC_SAMPLE_FREQUENCY 240000U

#define ADC_CHANNEL_OFFSET_BOUND_MAX  ((65535U / 2) + 10000U)
#define ADC_CHANNEL_OFFSET_BOUND_MIN  ((65535U / 2) - 10000U)

#define NUM_MICROPHONE_CHANNELS 6

// Number of samples for FFT op
#define FFT_BATCH_SIZE      512
#define FFT_NUMBER_OF_BINS  (FFT_BATCH_SIZE / 2)
// -1 for index offset, +1 to get bin above 20k
#define FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW  (FFT_BATCH_SIZE * 20000 / ADC_SAMPLE_FREQUENCY - 1 + 1)
#define FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_HIGH (FFT_BATCH_SIZE / 2 - 1)
#define FFT_SPECTRUM_NUMBER_OF_ULTRASONIC_BINS (FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_HIGH - FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW + 1)

// mask for bin counter
#define FFT_DETECT_COUNT_MASK (0x7F)
// use MSB of bin counters as detect state flag
#define FFT_DETECT_BIN_ACTIVE_FLAG (1 << 7)

// skip n data sets, then transmit the next set
#define USART_SKIP_N_DATA_SETS 5

#define OUTPUT_AUDIO_SAMPLE_CHUNK_SIZE 40
#define OUTPUT_AUDIO_FIR_TAPS   60

// buffer size of output audio stream used as single buffer
#define OUTPUT_AUDIO_BUFFER_SIZE  (OUTPUT_AUDIO_SAMPLE_CHUNK_SIZE)

// Number of adc samples decimated into 1 to get 16 ksps voice data
#define ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO  15

// Buffer size of each adc (samples per channel), also influences FFT op frequency
// Set by size of output audio buffer
// used as split buffer
#define ADC_BUFFER_SAMPLES_PER_CHANNEL (OUTPUT_AUDIO_BUFFER_SIZE * 2 * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO)

// includes
// include main.h for HAL
#include "main.h"
#include "math.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "arm_math.h"
#include "dsp.h"
#include <output_audio.h>
#include "ipc_interface.h"
#include "cmsis_gcc.h"
#include "app_x-cube-ai.h"


// private variables
union {
  float valuef;
  uint8_t valueu8[4];
} float_union;

// Type defs for already-defined peripheral structures, used with HAL
extern ADC_HandleTypeDef hadc1;
extern ADC_HandleTypeDef hadc3;
extern DMA_HandleTypeDef hdma_adc1;
extern DMA_HandleTypeDef hdma_adc3;
extern TIM_HandleTypeDef htim3;
extern UART_HandleTypeDef huart3;
extern UART_HandleTypeDef huart1;

// number of ADC DMA HT interrupts before data is used for FFT
// ADC batches in 1/400th second, skip 4, op on 5th -> 20 fft ops per second
static const uint8_t FFT_OP_ON_COUNT = 20;

// any bin for any channel must be above the trigger threshold this many times before
// it is considered an active event
static const uint8_t FFT_DETECT_THRESHOLD_RISING_COUNT = 14;
// any bin for any channel must be above the trigger threshold no more than this many
//   times before it is considered an inactive event
static const uint8_t FFT_DETECT_THRESHOLD_FALLING_COUNT = 10;
// max bound on fft anomaly detect bin counters
static const uint8_t FFT_DETECT_THRESHOLD_MAX_COUNT = 24;

// trigger threshold offset from the noise floor
static volatile float fft_trigger_threshold_offset_db = 3.0f;

// number of fft calcs used to define noise floor
static const uint8_t FFT_REQUIRED_NOISE_FLOOR_SAMPLES = 40;

// windowing constants for FFT data
#ifdef FFT_WINDOWING
#if FFT_BATCH_SIZE == 512
static const float HANN_WINDOW_COEFF[FFT_BATCH_SIZE] = { 0.0 , 3.77965772741e-05 , 0.000151180594771 , 0.000340134910381 , 0.000604630956797 , 0.000944628745838 , 0.00136007687449 , 0.0018509125327 , 0.00241706151281 , 0.00305843822087 , 0.00377494568948 , 0.00456647559254 , 0.00543290826156 , 0.00637411270378 , 0.00738994662197 , 0.00848025643596 , 0.00964487730582 , 0.0108836331568 , 0.0121963367061 , 0.0135827894907 , 0.0150427818981 , 0.0165760931974 , 0.0181824915728 , 0.019861734159 , 0.0216135670775 , 0.0234377254751 , 0.0253339335641 , 0.0273019046636 , 0.0293413412436 , 0.031451934969 , 0.0336333667469 , 0.0358853067749 , 0.0382074145903 , 0.0405993391223 , 0.0430607187446 , 0.0455911813302 , 0.0481903443081 , 0.0508578147201 , 0.0535931892815 , 0.0563960544408 , 0.0592659864435 , 0.0622025513949 , 0.0652053053267 , 0.0682737942636 , 0.0714075542921 , 0.0746061116306 , 0.0778689827009 , 0.0811956742018 , 0.0845856831828 , 0.0880384971212 , 0.0915535939987 , 0.0951304423808 , 0.098768501497 , 0.102467221322 , 0.106226042662 , 0.110044397232 , 0.11392170775 , 0.117857388021 , 0.121850843023 , 0.125901469 , 0.130008653553 , 0.134171775732 , 0.13839020613 , 0.142663306979 , 0.146990432243 , 0.15137092772 , 0.15580413114 , 0.160289372264 , 0.164825972983 , 0.169413247426 , 0.174050502061 , 0.178737035796 , 0.183472140094 , 0.188255099071 , 0.193085189608 , 0.197961681463 , 0.202883837376 , 0.207850913186 , 0.212862157937 , 0.217916814 , 0.223014117177 , 0.228153296829 , 0.233333575979 , 0.238554171443 , 0.243814293936 , 0.2491131482 , 0.254449933122 , 0.259823841852 , 0.265234061928 , 0.270679775401 , 0.276160158952 , 0.281674384022 , 0.287221616936 , 0.292801019029 , 0.298411746771 , 0.304052951897 , 0.309723781533 , 0.315423378329 , 0.321150880583 , 0.326905422376 , 0.332686133699 , 0.338492140587 , 0.344322565253 , 0.350176526215 , 0.356053138436 , 0.361951513451 , 0.367870759508 , 0.373809981696 , 0.379768282088 , 0.385744759869 , 0.391738511479 , 0.397748630743 , 0.403774209015 , 0.409814335308 , 0.41586809644 , 0.421934577163 , 0.428012860309 , 0.434102026926 , 0.440201156414 , 0.446309326668 , 0.452425614217 , 0.458549094362 , 0.464678841316 , 0.470813928346 , 0.47695342791 , 0.4830964118 , 0.489241951282 , 0.495389117233 , 0.501536980287 , 0.50768461097 , 0.513831079845 , 0.51997545765 , 0.52611681544 , 0.532254224725 , 0.538386757612 , 0.544513486947 , 0.550633486453 , 0.556745830868 , 0.562849596091 , 0.568943859316 , 0.575027699172 , 0.581100195868 , 0.587160431325 , 0.593207489317 , 0.599240455614 , 0.605258418112 , 0.611260466978 , 0.617245694785 , 0.623213196648 , 0.629162070363 , 0.635091416541 , 0.641000338747 , 0.646887943631 , 0.65275334107 , 0.658595644295 , 0.664413970029 , 0.670207438623 , 0.675975174181 , 0.681716304703 , 0.687429962208 , 0.693115282868 , 0.698771407141 , 0.704397479899 , 0.709992650557 , 0.7155560732 , 0.721086906717 , 0.72658431492 , 0.732047466677 , 0.737475536034 , 0.742867702341 , 0.748223150376 , 0.75354107047 , 0.758820658625 , 0.764061116639 , 0.769261652229 , 0.774421479142 , 0.779539817286 , 0.784615892836 , 0.789648938359 , 0.794638192929 , 0.799582902238 , 0.804482318714 , 0.809335701631 , 0.814142317226 , 0.818901438803 , 0.823612346849 , 0.828274329138 , 0.832886680843 , 0.83744870464 , 0.841959710812 , 0.846419017358 , 0.850825950091 , 0.855179842744 , 0.859480037067 , 0.863725882931 , 0.86791673842 , 0.872051969936 , 0.876130952287 , 0.880153068788 , 0.88411771135 , 0.888024280573 , 0.891872185837 , 0.895660845392 , 0.899389686443 , 0.903058145242 , 0.906665667168 , 0.910211706813 , 0.913695728063 , 0.917117204184 , 0.920475617893 , 0.923770461446 , 0.927001236708 , 0.930167455228 , 0.933268638318 , 0.936304317122 , 0.939274032687 , 0.942177336032 , 0.945013788217 , 0.947782960411 , 0.950484433951 , 0.953117800413 , 0.955682661666 , 0.95817862994 , 0.960605327878 , 0.962962388597 , 0.965249455741 , 0.967466183536 , 0.969612236845 , 0.971687291213 , 0.973691032921 , 0.975623159029 , 0.977483377428 , 0.979271406877 , 0.980986977051 , 0.982629828579 , 0.984199713085 , 0.985696393223 , 0.987119642716 , 0.988469246389 , 0.989745000199 , 0.990946711269 , 0.992074197919 , 0.993127289687 , 0.99410582736 , 0.995009662997 , 0.99583865995 , 0.996592692886 , 0.997271647805 , 0.99787542206 , 0.998403924367 , 0.998857074824 , 0.999234804921 , 0.999537057551 , 0.999763787017 , 0.99991495904 , 0.999990550766 , 0.999990550766 , 0.99991495904 , 0.999763787017 , 0.999537057551 , 0.999234804921 , 0.998857074824 , 0.998403924367 , 0.99787542206 , 0.997271647805 , 0.996592692886 , 0.99583865995 , 0.995009662997 , 0.99410582736 , 0.993127289687 , 0.992074197919 , 0.990946711269 , 0.989745000199 , 0.988469246389 , 0.987119642716 , 0.985696393223 , 0.984199713085 , 0.982629828579 , 0.980986977051 , 0.979271406877 , 0.977483377428 , 0.975623159029 , 0.973691032921 , 0.971687291213 , 0.969612236845 , 0.967466183536 , 0.965249455741 , 0.962962388597 , 0.960605327878 , 0.95817862994 , 0.955682661666 , 0.953117800413 , 0.950484433951 , 0.947782960411 , 0.945013788217 , 0.942177336032 , 0.939274032687 , 0.936304317122 , 0.933268638318 , 0.930167455228 , 0.927001236708 , 0.923770461446 , 0.920475617893 , 0.917117204184 , 0.913695728063 , 0.910211706813 , 0.906665667168 , 0.903058145242 , 0.899389686443 , 0.895660845392 , 0.891872185837 , 0.888024280573 , 0.88411771135 , 0.880153068788 , 0.876130952287 , 0.872051969936 , 0.86791673842 , 0.863725882931 , 0.859480037067 , 0.855179842744 , 0.850825950091 , 0.846419017358 , 0.841959710812 , 0.83744870464 , 0.832886680843 , 0.828274329138 , 0.823612346849 , 0.818901438803 , 0.814142317226 , 0.809335701631 , 0.804482318714 , 0.799582902238 , 0.794638192929 , 0.789648938359 , 0.784615892836 , 0.779539817286 , 0.774421479142 , 0.769261652229 , 0.764061116639 , 0.758820658625 , 0.75354107047 , 0.748223150376 , 0.742867702341 , 0.737475536034 , 0.732047466677 , 0.72658431492 , 0.721086906717 , 0.7155560732 , 0.709992650557 , 0.704397479899 , 0.698771407141 , 0.693115282868 , 0.687429962208 , 0.681716304703 , 0.675975174181 , 0.670207438623 , 0.664413970029 , 0.658595644295 , 0.65275334107 , 0.646887943631 , 0.641000338747 , 0.635091416541 , 0.629162070363 , 0.623213196648 , 0.617245694785 , 0.611260466978 , 0.605258418112 , 0.599240455614 , 0.593207489317 , 0.587160431325 , 0.581100195868 , 0.575027699172 , 0.568943859316 , 0.562849596091 , 0.556745830868 , 0.550633486453 , 0.544513486947 , 0.538386757612 , 0.532254224725 , 0.52611681544 , 0.51997545765 , 0.513831079845 , 0.50768461097 , 0.501536980287 , 0.495389117233 , 0.489241951282 , 0.4830964118 , 0.47695342791 , 0.470813928346 , 0.464678841316 , 0.458549094362 , 0.452425614217 , 0.446309326668 , 0.440201156414 , 0.434102026926 , 0.428012860309 , 0.421934577163 , 0.41586809644 , 0.409814335308 , 0.403774209015 , 0.397748630743 , 0.391738511479 , 0.385744759869 , 0.379768282088 , 0.373809981696 , 0.367870759508 , 0.361951513451 , 0.356053138436 , 0.350176526215 , 0.344322565253 , 0.338492140587 , 0.332686133699 , 0.326905422376 , 0.321150880583 , 0.315423378329 , 0.309723781533 , 0.304052951897 , 0.298411746771 , 0.292801019029 , 0.287221616936 , 0.281674384022 , 0.276160158952 , 0.270679775401 , 0.265234061928 , 0.259823841852 , 0.254449933122 , 0.2491131482 , 0.243814293936 , 0.238554171443 , 0.233333575979 , 0.228153296829 , 0.223014117177 , 0.217916814 , 0.212862157937 , 0.207850913186 , 0.202883837376 , 0.197961681463 , 0.193085189608 , 0.188255099071 , 0.183472140094 , 0.178737035796 , 0.174050502061 , 0.169413247426 , 0.164825972983 , 0.160289372264 , 0.15580413114 , 0.15137092772 , 0.146990432243 , 0.142663306979 , 0.13839020613 , 0.134171775732 , 0.130008653553 , 0.125901469 , 0.121850843023 , 0.117857388021 , 0.11392170775 , 0.110044397232 , 0.106226042662 , 0.102467221322 , 0.098768501497 , 0.0951304423808 , 0.0915535939987 , 0.0880384971212 , 0.0845856831828 , 0.0811956742018 , 0.0778689827009 , 0.0746061116306 , 0.0714075542921 , 0.0682737942636 , 0.0652053053267 , 0.0622025513949 , 0.0592659864435 , 0.0563960544408 , 0.0535931892815 , 0.0508578147201 , 0.0481903443081 , 0.0455911813302 , 0.0430607187446 , 0.0405993391223 , 0.0382074145903 , 0.0358853067749 , 0.0336333667469 , 0.031451934969 , 0.0293413412436 , 0.0273019046636 , 0.0253339335641 , 0.0234377254751 , 0.0216135670775 , 0.019861734159 , 0.0181824915728 , 0.0165760931974 , 0.0150427818981 , 0.0135827894907 , 0.0121963367061 , 0.0108836331568 , 0.00964487730582 , 0.00848025643596 , 0.00738994662197 , 0.00637411270378 , 0.00543290826156 , 0.00456647559254 , 0.00377494568948 , 0.00305843822087 , 0.00241706151281 , 0.0018509125327 , 0.00136007687449 , 0.000944628745838 , 0.000604630956797 , 0.000340134910381 , 0.000151180594771 , 3.77965772741e-05 , 0.0 };
#else
static const float HANN_WINDOW_COEFF[FFT_BATCH_SIZE] = { 0.0 , 9.43076911872e-06 , 3.77227207173e-05 , 8.48747875361e-05 , 0.000150885190854 , 0.000235751440556 , 0.000339470335226 , 0.000462037962268 , 0.000603449698054 , 0.000763700208099 , 0.000942783447259 , 0.00114069265996 , 0.00135742038047 , 0.00159295843314 , 0.00184729793276 , 0.00212042928485 , 0.00241234218606 , 0.00272302562455 , 0.00305246788036 , 0.00340065652594 , 0.00376757842652 , 0.0041532197407 , 0.00455756592088 , 0.0049806017139 , 0.00542231116153 , 0.00588267760114 , 0.00636168366629 , 0.0068593112874 , 0.00737554169243 , 0.00791035540756 , 0.008463732258 , 0.00903565136865 , 0.00962609116497 , 0.0102350293738 , 0.010862443024 , 0.0115083084477 , 0.0121726012808 , 0.0128552964642 , 0.0135563682445 , 0.0142757901751 , 0.0150135351173 , 0.0157695752409 , 0.0165438820259 , 0.017336426263 , 0.018147178055 , 0.0189761068179 , 0.0198231812819 , 0.0206883694927 , 0.0215716388128 , 0.0224729559226 , 0.0233922868215 , 0.0243295968297 , 0.0252848505889 , 0.026258012064 , 0.0272490445443 , 0.028257910645 , 0.0292845723087 , 0.0303289908064 , 0.0313911267396 , 0.0324709400411 , 0.033568389977 , 0.0346834351483 , 0.035816033492 , 0.0369661422829 , 0.0381337181354 , 0.039318717005 , 0.0405210941899 , 0.0417408043327 , 0.0429778014221 , 0.0442320387949 , 0.0455034691374 , 0.0467920444872 , 0.0480977162355 , 0.0494204351281 , 0.0507601512681 , 0.0521168141173 , 0.0534903724981 , 0.0548807745958 , 0.0562879679601 , 0.0577118995073 , 0.0591525155223 , 0.0606097616607 , 0.0620835829506 , 0.0635739237951 , 0.0650807279737 , 0.0666039386454 , 0.0681434983498 , 0.0696993490101 , 0.0712714319347 , 0.0728596878199 , 0.0744640567517 , 0.0760844782085 , 0.0777208910629 , 0.0793732335844 , 0.0810414434416 , 0.0827254577045 , 0.0844252128469 , 0.0861406447487 , 0.0878716886986 , 0.0896182793964 , 0.0913803509551 , 0.0931578369042 , 0.0949506701912 , 0.0967587831852 , 0.0985821076783 , 0.100420574889 , 0.102274115466 , 0.104142659486 , 0.106026136463 , 0.107924475346 , 0.109837604524 , 0.111765451828 , 0.113707944533 , 0.115665009364 , 0.117636572492 , 0.119622559546 , 0.121622895606 , 0.123637505215 , 0.125666312376 , 0.127709240554 , 0.129766212686 , 0.131837151174 , 0.133921977899 , 0.136020614212 , 0.138132980947 , 0.14025899842 , 0.14239858643 , 0.144551664266 , 0.146718150706 , 0.148897964025 , 0.151091021992 , 0.15329724188 , 0.155516540462 , 0.15774883402 , 0.159994038345 , 0.162252068741 , 0.164522840028 , 0.166806266546 , 0.169102262156 , 0.171410740247 , 0.173731613735 , 0.176064795071 , 0.17841019624 , 0.180767728765 , 0.183137303714 , 0.185518831698 , 0.187912222879 , 0.190317386972 , 0.192734233245 , 0.195162670529 , 0.197602607214 , 0.20005395126 , 0.202516610193 , 0.204990491114 , 0.207475500702 , 0.209971545214 , 0.212478530492 , 0.214996361964 , 0.21752494465 , 0.220064183164 , 0.222613981719 , 0.225174244127 , 0.227744873808 , 0.230325773791 , 0.232916846715 , 0.235517994837 , 0.238129120033 , 0.240750123806 , 0.243380907281 , 0.246021371217 , 0.248671416009 , 0.251330941689 , 0.25399984793 , 0.256678034054 , 0.259365399031 , 0.262061841485 , 0.264767259699 , 0.267481551615 , 0.270204614843 , 0.272936346659 , 0.275676644015 , 0.278425403538 , 0.281182521537 , 0.283947894004 , 0.286721416621 , 0.289502984763 , 0.292292493499 , 0.295089837602 , 0.297894911546 , 0.300707609516 , 0.303527825408 , 0.306355452835 , 0.30919038513 , 0.312032515351 , 0.314881736284 , 0.317737940447 , 0.320601020095 , 0.323470867226 , 0.326347373578 , 0.329230430641 , 0.332119929658 , 0.335015761627 , 0.33791781731 , 0.340825987231 , 0.343740161686 , 0.346660230742 , 0.349586084247 , 0.352517611827 , 0.355454702896 , 0.358397246659 , 0.361345132113 , 0.364298248055 , 0.367256483085 , 0.370219725609 , 0.373187863844 , 0.376160785823 , 0.379138379398 , 0.382120532245 , 0.385107131869 , 0.388098065605 , 0.391093220626 , 0.394092483945 , 0.397095742423 , 0.400102882765 , 0.403113791534 , 0.406128355149 , 0.409146459891 , 0.412167991908 , 0.415192837218 , 0.418220881716 , 0.421252011174 , 0.424286111248 , 0.427323067483 , 0.430362765315 , 0.433405090078 , 0.436449927006 , 0.439497161238 , 0.442546677824 , 0.445598361725 , 0.448652097824 , 0.451707770923 , 0.454765265754 , 0.457824466978 , 0.460885259194 , 0.463947526937 , 0.467011154691 , 0.470076026885 , 0.473142027904 , 0.476209042088 , 0.47927695374 , 0.48234564713 , 0.485415006495 , 0.488484916052 , 0.491555259993 , 0.494625922496 , 0.497696787725 , 0.500767739838 , 0.503838662991 , 0.506909441336 , 0.509979959037 , 0.513050100263 , 0.516119749198 , 0.519188790048 , 0.522257107037 , 0.525324584419 , 0.528391106481 , 0.531456557542 , 0.534520821965 , 0.537583784157 , 0.540645328573 , 0.543705339722 , 0.546763702171 , 0.549820300549 , 0.552875019552 , 0.555927743947 , 0.558978358575 , 0.562026748359 , 0.565072798302 , 0.568116393499 , 0.571157419137 , 0.574195760497 , 0.577231302965 , 0.580263932031 , 0.583293533295 , 0.58631999247 , 0.589343195389 , 0.592363028009 , 0.59537937641 , 0.598392126808 , 0.601401165553 , 0.604406379133 , 0.607407654184 , 0.610404877488 , 0.61339793598 , 0.616386716752 , 0.61937110706 , 0.622350994323 , 0.625326266129 , 0.628296810244 , 0.631262514607 , 0.634223267345 , 0.637178956769 , 0.64012947138 , 0.643074699876 , 0.646014531155 , 0.648948854316 , 0.651877558668 , 0.654800533732 , 0.657717669243 , 0.660628855158 , 0.663533981659 , 0.666432939155 , 0.669325618288 , 0.672211909938 , 0.675091705225 , 0.677964895514 , 0.68083137242 , 0.683691027811 , 0.68654375381 , 0.689389442805 , 0.692227987448 , 0.69505928066 , 0.697883215635 , 0.700699685847 , 0.70350858505 , 0.706309807282 , 0.709103246874 , 0.711888798448 , 0.714666356924 , 0.717435817526 , 0.720197075779 , 0.722950027521 , 0.725694568902 , 0.72843059639 , 0.731158006773 , 0.733876697164 , 0.736586565008 , 0.739287508078 , 0.741979424487 , 0.744662212687 , 0.747335771477 , 0.75 , 0.752654797754 , 0.755300064592 , 0.757935700726 , 0.760561606732 , 0.763177683552 , 0.7657838325 , 0.768379955265 , 0.770965953912 , 0.77354173089 , 0.776107189032 , 0.778662231561 , 0.781206762094 , 0.783740684643 , 0.78626390362 , 0.788776323841 , 0.791277850532 , 0.793768389326 , 0.796247846272 , 0.798716127839 , 0.801173140914 , 0.803618792811 , 0.806052991274 , 0.808475644476 , 0.810886661028 , 0.813285949979 , 0.815673420819 , 0.818048983487 , 0.82041254837 , 0.822764026305 , 0.825103328587 , 0.827430366973 , 0.829745053677 , 0.832047301384 , 0.834337023244 , 0.836614132884 , 0.838878544403 , 0.841130172381 , 0.843368931879 , 0.845594738445 , 0.847807508114 , 0.850007157414 , 0.852193603367 , 0.854366763493 , 0.856526555816 , 0.858672898859 , 0.860805711658 , 0.862924913755 , 0.865030425208 , 0.86712216659 , 0.869200058994 , 0.871264024037 , 0.873313983858 , 0.875349861128 , 0.877371579045 , 0.879379061346 , 0.881372232302 , 0.883351016724 , 0.885315339966 , 0.887265127928 , 0.889200307057 , 0.891120804354 , 0.893026547371 , 0.894917464218 , 0.896793483563 , 0.898654534636 , 0.900500547235 , 0.90233145172 , 0.904147179026 , 0.905947660656 , 0.907732828692 , 0.909502615791 , 0.911256955192 , 0.912995780715 , 0.914719026767 , 0.916426628341 , 0.918118521021 , 0.919794640985 , 0.921454925003 , 0.923099310445 , 0.924727735279 , 0.926340138077 , 0.927936458012 , 0.929516634869 , 0.931080609036 , 0.932628321516 , 0.934159713925 , 0.935674728494 , 0.937173308072 , 0.938655396128 , 0.940120936753 , 0.941569874662 , 0.943002155197 , 0.944417724327 , 0.945816528654 , 0.94719851541 , 0.948563632462 , 0.949911828314 , 0.951243052108 , 0.952557253625 , 0.953854383291 , 0.955134392173 , 0.956397231985 , 0.95764285509 , 0.958871214498 , 0.960082263872 , 0.961275957528 , 0.962452250436 , 0.963611098222 , 0.964752457172 , 0.965876284228 , 0.966982536998 , 0.96807117375 , 0.969142153418 , 0.9701954356 , 0.971230980564 , 0.972248749245 , 0.973248703251 , 0.974230804859 , 0.975195017023 , 0.976141303369 , 0.9770696282 , 0.977979956497 , 0.978872253919 , 0.979746486807 , 0.980602622182 , 0.981440627747 , 0.98226047189 , 0.983062123685 , 0.98384555289 , 0.984610729952 , 0.985357626007 , 0.986086212879 , 0.986796463084 , 0.987488349828 , 0.988161847012 , 0.988816929229 , 0.989453571768 , 0.990071750613 , 0.990671442443 , 0.991252624637 , 0.991815275271 , 0.992359373119 , 0.992884897657 , 0.993391829061 , 0.993880148207 , 0.994349836674 , 0.994800876744 , 0.995233251403 , 0.995646944341 , 0.99604193995 , 0.996418223332 , 0.996775780291 , 0.99711459734 , 0.997434661696 , 0.997735961287 , 0.998018484745 , 0.998282221415 , 0.998527161346 , 0.998753295299 , 0.998960614743 , 0.999149111858 , 0.999318779533 , 0.999469611367 , 0.99960160167 , 0.999714745465 , 0.999809038482 , 0.999884477164 , 0.999941058666 , 0.999978780853 , 0.999997642302 , 0.999997642302 , 0.999978780853 , 0.999941058666 , 0.999884477164 , 0.999809038482 , 0.999714745465 , 0.99960160167 , 0.999469611367 , 0.999318779533 , 0.999149111858 , 0.998960614743 , 0.998753295299 , 0.998527161346 , 0.998282221415 , 0.998018484745 , 0.997735961287 , 0.997434661696 , 0.99711459734 , 0.996775780291 , 0.996418223332 , 0.99604193995 , 0.995646944341 , 0.995233251403 , 0.994800876744 , 0.994349836674 , 0.993880148207 , 0.993391829061 , 0.992884897657 , 0.992359373119 , 0.991815275271 , 0.991252624637 , 0.990671442443 , 0.990071750613 , 0.989453571768 , 0.988816929229 , 0.988161847012 , 0.987488349828 , 0.986796463084 , 0.986086212879 , 0.985357626007 , 0.984610729952 , 0.98384555289 , 0.983062123685 , 0.98226047189 , 0.981440627747 , 0.980602622182 , 0.979746486807 , 0.978872253919 , 0.977979956497 , 0.9770696282 , 0.976141303369 , 0.975195017023 , 0.974230804859 , 0.973248703251 , 0.972248749245 , 0.971230980564 , 0.9701954356 , 0.969142153418 , 0.96807117375 , 0.966982536998 , 0.965876284228 , 0.964752457172 , 0.963611098222 , 0.962452250436 , 0.961275957528 , 0.960082263872 , 0.958871214498 , 0.95764285509 , 0.956397231985 , 0.955134392173 , 0.953854383291 , 0.952557253625 , 0.951243052108 , 0.949911828314 , 0.948563632462 , 0.94719851541 , 0.945816528654 , 0.944417724327 , 0.943002155197 , 0.941569874662 , 0.940120936753 , 0.938655396128 , 0.937173308072 , 0.935674728494 , 0.934159713925 , 0.932628321516 , 0.931080609036 , 0.929516634869 , 0.927936458012 , 0.926340138077 , 0.924727735279 , 0.923099310445 , 0.921454925003 , 0.919794640985 , 0.918118521021 , 0.916426628341 , 0.914719026767 , 0.912995780715 , 0.911256955192 , 0.909502615791 , 0.907732828692 , 0.905947660656 , 0.904147179026 , 0.90233145172 , 0.900500547235 , 0.898654534636 , 0.896793483563 , 0.894917464218 , 0.893026547371 , 0.891120804354 , 0.889200307057 , 0.887265127928 , 0.885315339966 , 0.883351016724 , 0.881372232302 , 0.879379061346 , 0.877371579045 , 0.875349861128 , 0.873313983858 , 0.871264024037 , 0.869200058994 , 0.86712216659 , 0.865030425208 , 0.862924913755 , 0.860805711658 , 0.858672898859 , 0.856526555816 , 0.854366763493 , 0.852193603367 , 0.850007157414 , 0.847807508114 , 0.845594738445 , 0.843368931879 , 0.841130172381 , 0.838878544403 , 0.836614132884 , 0.834337023244 , 0.832047301384 , 0.829745053677 , 0.827430366973 , 0.825103328587 , 0.822764026305 , 0.82041254837 , 0.818048983487 , 0.815673420819 , 0.813285949979 , 0.810886661028 , 0.808475644476 , 0.806052991274 , 0.803618792811 , 0.801173140914 , 0.798716127839 , 0.796247846272 , 0.793768389326 , 0.791277850532 , 0.788776323841 , 0.78626390362 , 0.783740684643 , 0.781206762094 , 0.778662231561 , 0.776107189032 , 0.77354173089 , 0.770965953912 , 0.768379955265 , 0.7657838325 , 0.763177683552 , 0.760561606732 , 0.757935700726 , 0.755300064592 , 0.752654797754 , 0.75 , 0.747335771477 , 0.744662212687 , 0.741979424487 , 0.739287508078 , 0.736586565008 , 0.733876697164 , 0.731158006773 , 0.72843059639 , 0.725694568902 , 0.722950027521 , 0.720197075779 , 0.717435817526 , 0.714666356924 , 0.711888798448 , 0.709103246874 , 0.706309807282 , 0.70350858505 , 0.700699685847 , 0.697883215635 , 0.69505928066 , 0.692227987448 , 0.689389442805 , 0.68654375381 , 0.683691027811 , 0.68083137242 , 0.677964895514 , 0.675091705225 , 0.672211909938 , 0.669325618288 , 0.666432939155 , 0.663533981659 , 0.660628855158 , 0.657717669243 , 0.654800533732 , 0.651877558668 , 0.648948854316 , 0.646014531155 , 0.643074699876 , 0.64012947138 , 0.637178956769 , 0.634223267345 , 0.631262514607 , 0.628296810244 , 0.625326266129 , 0.622350994323 , 0.61937110706 , 0.616386716752 , 0.61339793598 , 0.610404877488 , 0.607407654184 , 0.604406379133 , 0.601401165553 , 0.598392126808 , 0.59537937641 , 0.592363028009 , 0.589343195389 , 0.58631999247 , 0.583293533295 , 0.580263932031 , 0.577231302965 , 0.574195760497 , 0.571157419137 , 0.568116393499 , 0.565072798302 , 0.562026748359 , 0.558978358575 , 0.555927743947 , 0.552875019552 , 0.549820300549 , 0.546763702171 , 0.543705339722 , 0.540645328573 , 0.537583784157 , 0.534520821965 , 0.531456557542 , 0.528391106481 , 0.525324584419 , 0.522257107037 , 0.519188790048 , 0.516119749198 , 0.513050100263 , 0.509979959037 , 0.506909441336 , 0.503838662991 , 0.500767739838 , 0.497696787725 , 0.494625922496 , 0.491555259993 , 0.488484916052 , 0.485415006495 , 0.48234564713 , 0.47927695374 , 0.476209042088 , 0.473142027904 , 0.470076026885 , 0.467011154691 , 0.463947526937 , 0.460885259194 , 0.457824466978 , 0.454765265754 , 0.451707770923 , 0.448652097824 , 0.445598361725 , 0.442546677824 , 0.439497161238 , 0.436449927006 , 0.433405090078 , 0.430362765315 , 0.427323067483 , 0.424286111248 , 0.421252011174 , 0.418220881716 , 0.415192837218 , 0.412167991908 , 0.409146459891 , 0.406128355149 , 0.403113791534 , 0.400102882765 , 0.397095742423 , 0.394092483945 , 0.391093220626 , 0.388098065605 , 0.385107131869 , 0.382120532245 , 0.379138379398 , 0.376160785823 , 0.373187863844 , 0.370219725609 , 0.367256483085 , 0.364298248055 , 0.361345132113 , 0.358397246659 , 0.355454702896 , 0.352517611827 , 0.349586084247 , 0.346660230742 , 0.343740161686 , 0.340825987231 , 0.33791781731 , 0.335015761627 , 0.332119929658 , 0.329230430641 , 0.326347373578 , 0.323470867226 , 0.320601020095 , 0.317737940447 , 0.314881736284 , 0.312032515351 , 0.30919038513 , 0.306355452835 , 0.303527825408 , 0.300707609516 , 0.297894911546 , 0.295089837602 , 0.292292493499 , 0.289502984763 , 0.286721416621 , 0.283947894004 , 0.281182521537 , 0.278425403538 , 0.275676644015 , 0.272936346659 , 0.270204614843 , 0.267481551615 , 0.264767259699 , 0.262061841485 , 0.259365399031 , 0.256678034054 , 0.25399984793 , 0.251330941689 , 0.248671416009 , 0.246021371217 , 0.243380907281 , 0.240750123806 , 0.238129120033 , 0.235517994837 , 0.232916846715 , 0.230325773791 , 0.227744873808 , 0.225174244127 , 0.222613981719 , 0.220064183164 , 0.21752494465 , 0.214996361964 , 0.212478530492 , 0.209971545214 , 0.207475500702 , 0.204990491114 , 0.202516610193 , 0.20005395126 , 0.197602607214 , 0.195162670529 , 0.192734233245 , 0.190317386972 , 0.187912222879 , 0.185518831698 , 0.183137303714 , 0.180767728765 , 0.17841019624 , 0.176064795071 , 0.173731613735 , 0.171410740247 , 0.169102262156 , 0.166806266546 , 0.164522840028 , 0.162252068741 , 0.159994038345 , 0.15774883402 , 0.155516540462 , 0.15329724188 , 0.151091021992 , 0.148897964025 , 0.146718150706 , 0.144551664266 , 0.14239858643 , 0.14025899842 , 0.138132980947 , 0.136020614212 , 0.133921977899 , 0.131837151174 , 0.129766212686 , 0.127709240554 , 0.125666312376 , 0.123637505215 , 0.121622895606 , 0.119622559546 , 0.117636572492 , 0.115665009364 , 0.113707944533 , 0.111765451828 , 0.109837604524 , 0.107924475346 , 0.106026136463 , 0.104142659486 , 0.102274115466 , 0.100420574889 , 0.0985821076783 , 0.0967587831852 , 0.0949506701912 , 0.0931578369042 , 0.0913803509551 , 0.0896182793964 , 0.0878716886986 , 0.0861406447487 , 0.0844252128469 , 0.0827254577045 , 0.0810414434416 , 0.0793732335844 , 0.0777208910629 , 0.0760844782085 , 0.0744640567517 , 0.0728596878199 , 0.0712714319347 , 0.0696993490101 , 0.0681434983498 , 0.0666039386454 , 0.0650807279737 , 0.0635739237951 , 0.0620835829506 , 0.0606097616607 , 0.0591525155223 , 0.0577118995073 , 0.0562879679601 , 0.0548807745958 , 0.0534903724981 , 0.0521168141173 , 0.0507601512681 , 0.0494204351281 , 0.0480977162355 , 0.0467920444872 , 0.0455034691374 , 0.0442320387949 , 0.0429778014221 , 0.0417408043327 , 0.0405210941899 , 0.039318717005 , 0.0381337181354 , 0.0369661422829 , 0.035816033492 , 0.0346834351483 , 0.033568389977 , 0.0324709400411 , 0.0313911267396 , 0.0303289908064 , 0.0292845723087 , 0.028257910645 , 0.0272490445443 , 0.026258012064 , 0.0252848505889 , 0.0243295968297 , 0.0233922868215 , 0.0224729559226 , 0.0215716388128 , 0.0206883694927 , 0.0198231812819 , 0.0189761068179 , 0.018147178055 , 0.017336426263 , 0.0165438820259 , 0.0157695752409 , 0.0150135351173 , 0.0142757901751 , 0.0135563682445 , 0.0128552964642 , 0.0121726012808 , 0.0115083084477 , 0.010862443024 , 0.0102350293738 , 0.00962609116497 , 0.00903565136865 , 0.008463732258 , 0.00791035540756 , 0.00737554169243 , 0.0068593112874 , 0.00636168366629 , 0.00588267760114 , 0.00542231116153 , 0.0049806017139 , 0.00455756592088 , 0.0041532197407 , 0.00376757842652 , 0.00340065652594 , 0.00305246788036 , 0.00272302562455 , 0.00241234218606 , 0.00212042928485 , 0.00184729793276 , 0.00159295843314 , 0.00135742038047 , 0.00114069265996 , 0.000942783447259 , 0.000763700208099 , 0.000603449698054 , 0.000462037962268 , 0.000339470335226 , 0.000235751440556 , 0.000150885190854 , 8.48747875361e-05 , 3.77227207173e-05 , 9.43076911872e-06 , 0.0 };
#endif
#endif

// fixed point FIR filter coefficients, signed .15b
// REMOVED OUTPUT AUDIO EXTERNALIZED
//static const int16_t OUTPUT_AUDIO_FIR_COEFFICIENTS[OUTPUT_AUDIO_FIR_TAPS] = {2, 6, 11, 17, 27, 40, 57, 79, 107, 141, 181, 227, 280, 339, 404, 474, 548, 625, 705, 784, 863, 939, 1012, 1079, 1140, 1193, 1236, 1270, 1293, 1304, 1304, 1293, 1270, 1236, 1193, 1140, 1079, 1012, 939, 863, 784, 705, 625, 548, 474, 404, 339, 280, 227, 181, 141, 107, 79, 57, 40, 27, 17, 11, 6, 2};

// buffers for raw adc values, filled by each DMA
static volatile uint16_t adc1_read_buffer[ADC1_CHANNELS * ADC_BUFFER_SAMPLES_PER_CHANNEL];
static volatile uint16_t adc3_read_buffer[ADC3_CHANNELS * ADC_BUFFER_SAMPLES_PER_CHANNEL];
// correction factor for dc offset for each channel, should always be positive (subtract this value from adc value)
// these offsets begin at half of the full scale range for uint16
static volatile uint16_t adc_channel_dynamic_offsets[ADC1_CHANNELS + ADC3_CHANNELS] = { 65535/2, 65535/2, 65535/2 ,65535/2, 65535/2, 65535/2 };

// REMOVED OUTPUT AUDIO EXTERNALIZED
// input buffer for FIR filter, used as split buffer due to 60 tap FIR and 15:1 downsampling overlap
//static volatile int16_t output_audio_filter_input_buffer[OUTPUT_AUDIO_BUFFER_SIZE * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO * 2];
// buffer for filtered audio data for each microphone, mono 16 ksps 16 bit, not a split buffer
//static volatile int16_t output_audio_filtered_buffer[OUTPUT_AUDIO_BUFFER_SIZE];
//static volatile int16_t output_audio_base_gain = 1;

// skip counter so FFT is performed every n ADC3 DMA half/complete transfer interrupts
static volatile uint16_t fft_op_skip_counter = 0;

// boolean flag, set after samples are moved to fft input buffer
// base loop evaluates flag and performs fft ops
static volatile boolean_t fft_samples_ready = FALSE;
static volatile boolean_t fft_results_ready = FALSE;
static volatile boolean_t localization_data_ready = FALSE;

// have skipped n fft data sets without uart transmission
static uint16_t usart_data_skip_counter = 0;

// dedicated sample buffers to save raw adc data for fft ops
static volatile float fft_sample_buffer[ADC1_CHANNELS + ADC3_CHANNELS][FFT_BATCH_SIZE];
// calculated fft data for each channel
static volatile float fft_out_buffer[ADC1_CHANNELS + ADC3_CHANNELS][FFT_BATCH_SIZE];

// noise floor spectrum, sampled at startup
static volatile float fft_noise_floor[FFT_NUMBER_OF_BINS];
static uint16_t noise_floor_samples = 0;

// fft spectrum magnitudes for each channel, including past ops when averaging
volatile float           fft_frequency_magnitude_db_average[ADC1_CHANNELS + ADC3_CHANNELS][FFT_NUMBER_OF_BINS];
static volatile float    fft_frequency_magnitude_db[ADC1_CHANNELS + ADC3_CHANNELS][FFT_AVERAGE_SAMPLES][FFT_NUMBER_OF_BINS];
static volatile uint16_t fft_frequency_magnitude_db_index = 0;

// counts for fft bins of each channel to determine trigger status
// each count is an occurence of that bin having a magnitude larger than
// the associated bin in the noise floor threshold
static uint8_t fft_magnitude_trigger_counter[ADC1_CHANNELS + ADC3_CHANNELS][FFT_SPECTRUM_NUMBER_OF_ULTRASONIC_BINS] = {0};

// largest magnitude of any channel above the trigger threshold within the ultrasonic range
static volatile float fft_channel_magnitude_db[NUM_MICROPHONE_CHANNELS];
static volatile float fft_channel_magnitude_bin[NUM_MICROPHONE_CHANNELS];

// boolean flags for each channel, true if that channel has a 'detected' anomaly in any bin
static volatile boolean_t channel_is_active_anomaly[NUM_MICROPHONE_CHANNELS];

// state flags for microphone channels, TRUE if channel is valid
static volatile boolean_t channel_is_valid[NUM_MICROPHONE_CHANNELS];

// anomaly variables used to pass anomaly characteristics to other subsystems
static float anomaly_frequency = 0.0f;
static float anomaly_frequency_normalized = 0.0f;
static float anomaly_magnitude = 0.0f;

#ifdef FFT_AVERAGING

#else

// single fft spectrum magnitude buffer when not averaging several ops
static volatile float fft_frequency_magnitude_db[ADC_CHANNELS][FFT_BATCH_SIZE];

#endif

// structure used for ARM dsp fft functions
static arm_rfft_fast_instance_f32 fft_handler;

// type of data being exported via uart
// false -> spectrum data for all channels
// true -> live voice audio data
static boolean_t uart_data_flag = FALSE;
static boolean_t user_button_state_previous;
static boolean_t user_button_state_current = FALSE;

static boolean_t anomaly_detect_state_previous;
static boolean_t anomaly_detect_state_current = FALSE;

static boolean_t debug_output_enable = FALSE;

// AI Inference flags
static boolean_t RUN_ONCE   = TRUE;
static int       SKIP_N_SAMPLES_READY = 0;
// Private functions
// Calc magnitude of complex vector
static float complexABS(float real, float compl);

// perform FFT ops on fft sample buffers
static void performFFT( void );

// REMOVED OUTPUT AUDIO EXTERNALIZED
// implementation of FIR filter for output audio
// two buffer pointers for current and previous, due to the number of taps on the FIR
//   and relatively low downsample rate
//static void performOutputAudioFIR( volatile int16_t *_current_data_buffer, volatile int16_t *_previous_data_buffer );

// half-transfer callback of ADC3 DMA, in step with ADC1 DMA -> same trigger
static void ADC3DMAHalfTransferIRQCallback(DMA_HandleTypeDef *_hdma);

// transfer complete callback of ADC3 DMA, in step with ADC1 DMA -> same trigger
static void ADC3DMATransferCompleteIRQCallback(DMA_HandleTypeDef *_hdma);

// copy samples from ADC1 and ADC3 buffers to a separate buffer so fft calculations can be
// performed on them by the lower priority while loop
static void copySamplesForFFT( volatile uint16_t *_source1, volatile uint16_t *_source2 );

static void anomalyDetectionLogic( void );

static void anomalyUpdateCharacteristics( void );

boolean_t dspGetIsAnomalyDetected( void )
{
  return anomaly_detect_state_current;
}

// simply averages dominant frequencies of active channels
float dspGetAnomalyFrequency( void )
{
  return anomaly_frequency;
}

// get normalized 0.0 to 1.0 anomaly frequency, within supported ultrasonic band
float dspGetAnomalyFrequencyNormalized( void )
{
  return anomaly_frequency_normalized;
}

// get largest spectrum magnitude of any channel relative to detection threshold
// returns -200.0f if no active anomaly
float dspGetAnomalyMagnitude( void )
{
  return anomaly_magnitude;
}

// returns boolean detect flag for each microphone
// if any microphone has one active fft bin, that microphone has an active anomaly
void dspGetMicrophoneAnomalyDetectStates( boolean_t *_mic_1, boolean_t *_mic_2, boolean_t *_mic_3,
                                       boolean_t *_mic_4, boolean_t *_mic_5, boolean_t *_mic_6 )
{
  *_mic_1 = channel_is_active_anomaly[0];
  *_mic_2 = channel_is_active_anomaly[1];
  *_mic_3 = channel_is_active_anomaly[2];
  *_mic_4 = channel_is_active_anomaly[3];
  *_mic_5 = channel_is_active_anomaly[4];
  *_mic_6 = channel_is_active_anomaly[5];
}

// get dominant frequency of microphones within ultrasonic band
void dspGetMicrophoneAnomalyDetectFrequencies( float *_mic_1_freq, float *_mic_2_freq, float *_mic_3_freq,
                                            float *_mic_4_freq, float *_mic_5_freq, float *_mic_6_freq )
{
  *_mic_1_freq = (float)fft_channel_magnitude_bin[0] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
  *_mic_2_freq = (float)fft_channel_magnitude_bin[1] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
  *_mic_3_freq = (float)fft_channel_magnitude_bin[2] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
  *_mic_4_freq = (float)fft_channel_magnitude_bin[3] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
  *_mic_5_freq = (float)fft_channel_magnitude_bin[4] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
  *_mic_6_freq = (float)fft_channel_magnitude_bin[5] * (ADC_SAMPLE_FREQUENCY / 2) / (FFT_BATCH_SIZE / 2);
}

void dspGetMicrophoneAnomalyMagnitudes( float *_mic_1_db, float *_mic_2_db, float *_mic_3_db,
                                     float *_mic_4_db, float *_mic_5_db, float *_mic_6_db )
{
  *_mic_1_db = fft_channel_magnitude_db[0];
  *_mic_2_db = fft_channel_magnitude_db[1];
  *_mic_3_db = fft_channel_magnitude_db[2];
  *_mic_4_db = fft_channel_magnitude_db[3];
  *_mic_5_db = fft_channel_magnitude_db[4];
  *_mic_6_db = fft_channel_magnitude_db[5];
}

void dspEntry( void )
{
  // init output audio subsystem
  // REMOVED OUTPUT AUDIO EXTERNALIZED
  //alarminit( );

  // init IPC
  IPCInitialize( );

  // get state of debug enable input, active low
  debug_output_enable = (boolean_t)(HAL_GPIO_ReadPin( DEBUG_EN_IN_GPIO_Port, DEBUG_EN_IN_Pin ) == GPIO_PIN_RESET);

  // Enable ADC boost level 3, required for 50 MHz ADC clock
  ADC1->CR |= ADC_CR_BOOST;
  ADC3->CR |= ADC_CR_BOOST;

  // calibrate offset and linearity for each ADC
  //HAL_ADCEx_Calibration_Start( &hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED );
  //HAL_ADCEx_Calibration_Start( &hadc3, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED );

  // set callback for ADC3 DMA, assume this DMA completes after/with ADC1 DMA
  HAL_DMA_RegisterCallback(&hdma_adc3, HAL_DMA_XFER_HALFCPLT_CB_ID, ADC3DMAHalfTransferIRQCallback);
  HAL_DMA_RegisterCallback(&hdma_adc3, HAL_DMA_XFER_CPLT_CB_ID, ADC3DMATransferCompleteIRQCallback);

  // Start DMA for each adc

  // ADC1 read DMA
  // Enable circular mode
  DMA1_Stream0->CR |= DMA_SxCR_CIRC;
  DMA1_Stream0->NDTR = ADC1_CHANNELS * ADC_BUFFER_SAMPLES_PER_CHANNEL;
  DMA1_Stream0->PAR = (uint32_t)&ADC1->DR;
  DMA1_Stream0->M0AR = (uint32_t)adc1_read_buffer;
  DMA1_Stream0->CR |= DMA_SxCR_EN;

  // ADC3 read DMA
  // Enable Half Transfer Interrupt, Transfer Complete Interrupt, Circular mode
  DMA1->LIFCR = DMA_LIFCR_CTCIF1;
  DMA1_Stream1->CR |= DMA_SxCR_HTIE | DMA_SxCR_TCIE | DMA_SxCR_CIRC;
  DMA1_Stream1->NDTR = ADC3_CHANNELS * ADC_BUFFER_SAMPLES_PER_CHANNEL;
  DMA1_Stream1->PAR = (uint32_t)&ADC3->DR;
  DMA1_Stream1->M0AR = (uint32_t)adc3_read_buffer;
  DMA1_Stream1->CR |= DMA_SxCR_EN;

  // Enable each ADC, TIM3 will trigger scan conversions
  ADC_Enable( &hadc1 );
  ADC_Enable( &hadc3 );

  while(!(ADC1->ISR | ADC_ISR_ADRDY) || !(ADC3->ISR | ADC_ISR_ADRDY));

  // Start each ADC, must be done before external trigger (TIM3) has effect
  ADC1->CR |= ADC_CR_ADSTART;
  ADC3->CR |= ADC_CR_ADSTART;

  // set TIM3 (ADC trigger) to stop in debug
  DBGMCU->APB1LFZ1 |= DBGMCU_APB1LFZ1_DBG_TIM3;

  // Set TIM3 to 240 kHz sample rate
  // 180 MHz base clock / 240000 = 750
  TIM3->ARR = 750;
  TIM3->CCR1 = 375;

  // Enable TIM3 output
  TIM3->CCER |= TIM_CCER_CC1E;

  // Start TIM3 counter, triggers ADC1 and ADC3 scan conversions on update events
  HAL_TIM_Base_Start( &htim3 );

  // init fft handler
  arm_rfft_fast_init_f32( &fft_handler, FFT_BATCH_SIZE );

  HAL_StatusTypeDef status;
  // union used to set start bytes of uart tx
  float_union.valueu8[0] = 0x55;
  float_union.valueu8[1] = 0x55;
  float_union.valueu8[2] = 0x55;
  float_union.valueu8[3] = 0x55;
  while (1)
  {
    if ( fft_samples_ready )
    {
      performFFT( );
      anomalyDetectionLogic( );
      fft_results_ready = TRUE;
      fft_samples_ready = FALSE;
      anomalyUpdateCharacteristics( );


      // Inference ANN every 40 FFT's (~3 seconds) when anomaly active.
      if(anomaly_detect_state_current & (((SKIP_N_SAMPLES_READY % 40) == 0) || (SKIP_N_SAMPLES_READY == 0)))
      {

    	    MX_X_CUBE_AI_Process(fft_frequency_magnitude_db_average);
      	    SKIP_N_SAMPLES_READY = 1;
      	    //RUN_ONCE = FALSE;
      }

      // Increment counter
      else if (anomaly_detect_state_current) SKIP_N_SAMPLES_READY++;


      // Check if button (green on front of UI) pressed
      // Used to send data out of USART3 USB for MATLAB script plotting
      user_button_state_previous = user_button_state_current;
      user_button_state_current = getUserButtonState( );

      if ( user_button_state_current && !user_button_state_previous )
      {
        uart_data_flag = (uart_data_flag ? FALSE : TRUE);
      }

      // Transmit data if button pressed
      if ( fft_results_ready && uart_data_flag )
      {
        usart_data_skip_counter++;

        if ( usart_data_skip_counter >= USART_SKIP_N_DATA_SETS )
        {
          usart_data_skip_counter = 0;

          status = HAL_UART_Transmit_DMA( &huart3, float_union.valueu8, 4 );
#ifdef FFT_AVERAGING

          // wait for uart available, transmit fft average data
          while ( (status = HAL_UART_Transmit_DMA( &huart3,
                                                (uint8_t*)fft_frequency_magnitude_db_average,
                                                ((ADC1_CHANNELS + ADC3_CHANNELS) * FFT_BATCH_SIZE / 2) * 4 ))
                == HAL_BUSY );

#else
          // wait for uart available
          while ( ( status = HAL_UART_Transmit_DMA( &huart3,
                                                  (uint8_t*)fft_frequency_magnitude_db,
                                                  (ADC_CHANNELS * FFT_BATCH_SIZE / 2) * 4 ))
                  == HAL_BUSY );
#endif
        }
        fft_results_ready = FALSE;
      }
    }
  }
}

uint32_t adc_dma_irq_count = 0;

void ADC3DMAHalfTransferIRQCallback(DMA_HandleTypeDef *_hdma)
{

  if ( debug_output_enable )
  {
    HAL_GPIO_WritePin( DEBUG_GPIO_0_GPIO_Port, DEBUG_GPIO_0_Pin, GPIO_PIN_SET );
  }

  setUserLED1State(TRUE);

  // check FFT skip counter, copy samples for FFT if zero
  if ( ++fft_op_skip_counter == FFT_OP_ON_COUNT )
  {
    fft_op_skip_counter = 0;
    // pass pointer to start of array, since first half just filled
    copySamplesForFFT( adc1_read_buffer, adc3_read_buffer );
  }

  // move adc samples to dedicated input buffers for filter operations
  uint32_t _channel_offset[6] = {0,0,0,0,0,0};
  for ( int index = 0; index < ADC_BUFFER_SAMPLES_PER_CHANNEL / 2; index++ )
  {
    // microphone 0 -> adc1 buffer index 0
    // microphone 1 -> adc3 buffer index 0
    // microphone 2 -> adc1 buffer index 1
    // microphone 3 -> adc1 buffer index 2
    // microphone 4 -> adc3 buffer index 1
    // microphone 5 -> adc3 buffer index 2

    // mix and average the six channels into one stream, change to floating point and expected offset
    // TODO - use only valid channels for voice?
	// REMOVED OUTPUT AUDIO EXTERNALIZED
    //output_audio_filter_input_buffer[index] = (int16_t)(((int32_t)adc1_read_buffer[0 + index * 3] - adc_channel_dynamic_offsets[0]
    //                                                    + (int32_t)adc3_read_buffer[0 + index * 3] - adc_channel_dynamic_offsets[1]
    //                                                    + (int32_t)adc1_read_buffer[1 + index * 3] - adc_channel_dynamic_offsets[2]
    //                                                    + (int32_t)adc1_read_buffer[2 + index * 3] - adc_channel_dynamic_offsets[3]
    //                                                    + (int32_t)adc3_read_buffer[1 + index * 3] - adc_channel_dynamic_offsets[4]
    //                                                    + (int32_t)adc3_read_buffer[2 + index * 3] - adc_channel_dynamic_offsets[5])
    //                                                      / 6);

    // sum values to determine channel offsets
    _channel_offset[0] += adc1_read_buffer[0 + index * 3];
    _channel_offset[1] += adc3_read_buffer[0 + index * 3];
    _channel_offset[2] += adc1_read_buffer[1 + index * 3];
    _channel_offset[3] += adc1_read_buffer[2 + index * 3];
    _channel_offset[4] += adc3_read_buffer[1 + index * 3];
    _channel_offset[5] += adc3_read_buffer[2 + index * 3];
  }

  _channel_offset[0] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[1] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[2] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[3] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[4] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[5] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;

  // compare measured offset values against acceptable bounds
  // adjust individual channel offsets, increment or decrement by one
  //    on each iteration to avoid output noise
  for ( int _channel = 0; _channel < NUM_MICROPHONE_CHANNELS; _channel++ )
  {
    if (( _channel_offset[_channel] > ADC_CHANNEL_OFFSET_BOUND_MIN )
         && ( _channel_offset[_channel] < ADC_CHANNEL_OFFSET_BOUND_MAX ))
    {
      // channel is valid
      channel_is_valid[_channel] = TRUE;

      if ( _channel_offset[_channel] > adc_channel_dynamic_offsets[_channel] )
      {
        adc_channel_dynamic_offsets[_channel]++;
      }
      else if ( _channel_offset[_channel] < adc_channel_dynamic_offsets[_channel] )
      {
        adc_channel_dynamic_offsets[_channel]--;
      }
    }
    else
    {
      channel_is_valid[_channel] = FALSE;
    }
  }

  // REMOVED OUTPUT AUDIO EXTERNALIZED
  //performOutputAudioFIR( &output_audio_filter_input_buffer[0], &output_audio_filter_input_buffer[ADC_BUFFER_SAMPLES_PER_CHANNEL / 2] );
  playAudio();
  setUserLED1State(FALSE);

  if ( debug_output_enable )
  {
    HAL_GPIO_WritePin( DEBUG_GPIO_0_GPIO_Port, DEBUG_GPIO_0_Pin, GPIO_PIN_RESET );
  }
}

void ADC3DMATransferCompleteIRQCallback(DMA_HandleTypeDef *_hdma)
{

  //if (AI_RUNNING) return;

  if ( debug_output_enable )
  {
    HAL_GPIO_WritePin( DEBUG_GPIO_0_GPIO_Port, DEBUG_GPIO_0_Pin, GPIO_PIN_SET );
  }

  setUserLED1State(TRUE);
  // TODO - Ensure ADC1 DMA consistently reaches this point first
  // Add flag for each and handle after whichever is second?

  // check FFT skip counter, copy samples for FFT if zero
  if ( ++fft_op_skip_counter == FFT_OP_ON_COUNT )
  {
    fft_op_skip_counter = 0;
    // pass pointer to midpoint of array, since second half just filled
    copySamplesForFFT( &adc1_read_buffer[(ADC1_CHANNELS*ADC_BUFFER_SAMPLES_PER_CHANNEL)/2],
                       &adc3_read_buffer[(ADC3_CHANNELS*ADC_BUFFER_SAMPLES_PER_CHANNEL)/2] );
  }

  // move adc samples to dedicated input buffers for filter ops
  uint32_t _channel_offset[6] = {0,0,0,0,0,0};
  for ( int index = ADC_BUFFER_SAMPLES_PER_CHANNEL / 2; index < ADC_BUFFER_SAMPLES_PER_CHANNEL; index++ )
  {
    // microphone 0 -> adc1 buffer index 0
    // microphone 1 -> adc3 buffer index 0
    // microphone 2 -> adc1 buffer index 1
    // microphone 3 -> adc1 buffer index 2
    // microphone 4 -> adc3 buffer index 1
    // microphone 5 -> adc3 buffer index 2

    // mix and average the six channels into one stream, change to floating point and expected offset
	// REMOVED OUTPUT AUDIO EXTERNALIZED
    //output_audio_filter_input_buffer[index] = (int16_t)(((int32_t)adc1_read_buffer[0 + index * 3] - adc_channel_dynamic_offsets[0]
    //                                                    + (int32_t)adc3_read_buffer[0 + index * 3] - adc_channel_dynamic_offsets[1]
    //                                                    + (int32_t)adc1_read_buffer[1 + index * 3] - adc_channel_dynamic_offsets[2]
    //                                                    + (int32_t)adc1_read_buffer[2 + index * 3] - adc_channel_dynamic_offsets[3]
    //                                                    + (int32_t)adc3_read_buffer[1 + index * 3] - adc_channel_dynamic_offsets[4]
    //                                                    + (int32_t)adc3_read_buffer[2 + index * 3] - adc_channel_dynamic_offsets[5])
    //                                                      / 6);

    // sum values to determine channel offsets
    _channel_offset[0] += adc1_read_buffer[0 + index * 3];
    _channel_offset[1] += adc3_read_buffer[0 + index * 3];
    _channel_offset[2] += adc1_read_buffer[1 + index * 3];
    _channel_offset[3] += adc1_read_buffer[2 + index * 3];
    _channel_offset[4] += adc3_read_buffer[1 + index * 3];
    _channel_offset[5] += adc3_read_buffer[2 + index * 3];
  }

  _channel_offset[0] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[1] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[2] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[3] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[4] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;
  _channel_offset[5] /= ADC_BUFFER_SAMPLES_PER_CHANNEL / 2;

  // compare measured offset values against acceptable bounds
  // adjust individual channel offsets, increment or decrement by one
  //    on each iteration to avoid output noise
  for ( int _channel = 0; _channel < NUM_MICROPHONE_CHANNELS; _channel++ )
  {
    if (( _channel_offset[_channel] > ADC_CHANNEL_OFFSET_BOUND_MIN )
         && ( _channel_offset[_channel] < ADC_CHANNEL_OFFSET_BOUND_MAX ))
    {
      // channel is valid
      channel_is_valid[_channel] = TRUE;

      if ( _channel_offset[_channel] > adc_channel_dynamic_offsets[_channel] )
      {
        adc_channel_dynamic_offsets[_channel]++;
      }
      else if ( _channel_offset[_channel] < adc_channel_dynamic_offsets[_channel] )
      {
        adc_channel_dynamic_offsets[_channel]--;
      }
    }
    else
    {
      channel_is_valid[_channel] = FALSE;
    }
  }

  // REMOVED OUTPUT AUDIO EXTERNALIZED
  //performOutputAudioFIR( &output_audio_filter_input_buffer[ADC_BUFFER_SAMPLES_PER_CHANNEL / 2], &output_audio_filter_input_buffer[0] );
  playAudio();
  setUserLED1State(FALSE);

  if ( debug_output_enable )
  {
    HAL_GPIO_WritePin( DEBUG_GPIO_0_GPIO_Port, DEBUG_GPIO_0_Pin, GPIO_PIN_RESET );
  }
}

////////////////////////////////////
// REMOVED OUTPUT AUDIO EXTERNALIZED
////////////////////////////////////

/*static void performOutputAudioFIR( volatile int16_t *_current_data_buffer, volatile int16_t *_previous_data_buffer )
{
  //setUserLED1State( TRUE );
  // output audio FIR, uses last 45 data from previous_data_buffer
  //    during calculation of first 3 current output samples,
  //    so current and previous buffer pointers are used

  int32_t _temp = 0;

  // perform overlap calculations first, those that use both buffers
  // index 0 of output audio buffer
  // TODO - Create nested for loops for the samples which use both buffers
  // define index outside of loop so it persists between for loops
  int _index;
  for ( _index = 0; _index < 45; _index++ )
  {
    _temp += ((int32_t)_previous_data_buffer[OUTPUT_AUDIO_BUFFER_SIZE * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO - 45 + _index]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  // continue index variable, offset applied inside loop
  for ( ; _index < 60; _index++ )
  {
    _temp += ((int32_t)_current_data_buffer[_index - 45]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  output_audio_filtered_buffer[0] = _temp * output_audio_base_gain;
  _temp = 0;

  // index 1 of output audio buffer
  for ( _index = 0; _index < 30; _index++ )
  {
    _temp += ((int32_t)_previous_data_buffer[OUTPUT_AUDIO_BUFFER_SIZE * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO - 30 + _index]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  for ( ; _index < 60; _index++ )
  {
    _temp += ((int32_t)_current_data_buffer[_index - 30]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  output_audio_filtered_buffer[1] = _temp * output_audio_base_gain;
  _temp = 0;

  // index 2 of output audio buffer
  for ( _index = 0; _index < 15; _index++ )
  {
    _temp += ((int32_t)_previous_data_buffer[OUTPUT_AUDIO_BUFFER_SIZE * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO - 15 + _index]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  for ( ; _index < 60; _index++ )
  {
    _temp += ((int32_t)_current_data_buffer[_index - 15]
           * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_index])
           >> 16;
  }

  output_audio_filtered_buffer[2] = _temp * output_audio_base_gain;

  // for loop the rest, reliant only on current_data_buffer
  for ( int _fir_output_buffer_index = 3; _fir_output_buffer_index < OUTPUT_AUDIO_BUFFER_SIZE; _fir_output_buffer_index++ )
  {
    _temp = 0;
    for ( int _tap_index = 0; _tap_index < OUTPUT_AUDIO_FIR_TAPS; _tap_index++ )
    {
      _temp += ((int32_t)_current_data_buffer[(_fir_output_buffer_index + 1)
                                            * ADC_OUTPUT_AUDIO_OVERSAMPLING_RATIO
                                            - OUTPUT_AUDIO_FIR_TAPS + _tap_index]
             * (int32_t)OUTPUT_AUDIO_FIR_COEFFICIENTS[_tap_index])
             >> 16;
    }

    output_audio_filtered_buffer[_fir_output_buffer_index] = _temp * output_audio_base_gain;
  }

  // uart the data outif ( uart_data_flag )
  /*if ( uart_data_flag )
  {
    HAL_UART_Transmit_DMA( &huart3, (uint8_t*)output_audio_filtered_buffer, OUTPUT_AUDIO_BUFFER_SIZE*2 );
  }

  // send data to output audio subsystem
  if ( !uart_data_flag )
  {
    playAudio( output_audio_filtered_buffer, OUTPUT_AUDIO_BUFFER_SIZE );
  }

  //setUserLED1State( FALSE );
}*/

static void copySamplesForFFT( volatile uint16_t *_source1, volatile uint16_t *_source2 )
{
  int _index;
  //if (!RUN_ONCE) printf("In copySamplesforFFT\r\n");
  for ( _index = 0; _index < FFT_BATCH_SIZE; _index++ )
  {

    // ADC1 packed microphone 0,2,3
    // ADC3 packed microphone 1,4,5

    // convert to voltage
    // apply HANN_WINDOW_COEFF
    fft_sample_buffer[0][_index] = (3.3f / 65535.0f * (float)_source1[0 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
    fft_sample_buffer[1][_index] = (3.3f / 65535.0f * (float)_source2[0 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
    fft_sample_buffer[2][_index] = (3.3f / 65535.0f * (float)_source1[1 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
    fft_sample_buffer[3][_index] = (3.3f / 65535.0f * (float)_source1[2 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
    fft_sample_buffer[4][_index] = (3.3f / 65535.0f * (float)_source2[1 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
    fft_sample_buffer[5][_index] = (3.3f / 65535.0f * (float)_source2[2 + _index * 3]
                                  - (0.0f)) * HANN_WINDOW_COEFF[_index];
  }

  // set ready for FFT flag so base loop or an RTOS task can perform the op without blocking interrupts
  fft_samples_ready = TRUE;
}

static float complexABS(float _real, float _compl)
{
  return sqrtf(_real * _real + _compl * _compl);
}

static void performFFT( void )
{

  for ( int _channel = 0; _channel < (ADC1_CHANNELS + ADC3_CHANNELS); _channel++ )
  {

    arm_rfft_fast_f32( &fft_handler, (float*)&fft_sample_buffer[_channel][0], (float*)&fft_out_buffer[_channel][0], 0);
  }

  //calculate abs values and linear-to-dB
  for ( int _channel = 0; _channel < (ADC1_CHANNELS + ADC3_CHANNELS); _channel++ )
  {

	  for ( int _i=0; _i<FFT_BATCH_SIZE / 2; _i++ )
    {
#ifdef FFT_AVERAGING
      // compute magnitude, correct for dc offset, save value to current magnitude buffer

      fft_frequency_magnitude_db[_channel][fft_frequency_magnitude_db_index][_i]
                = (20.0f * log10f(complexABS(fft_out_buffer[_channel][_i*2] / (FFT_BATCH_SIZE / 8),
                                    fft_out_buffer[_channel][(_i*2)+1] / (FFT_BATCH_SIZE / 8))));

      // sampling for noise floor at startup
      if ( noise_floor_samples < FFT_REQUIRED_NOISE_FLOOR_SAMPLES )
      {
        if (( fft_frequency_magnitude_db[_channel][fft_frequency_magnitude_db_index][_i]
              > fft_noise_floor[_i] )
            || ( noise_floor_samples == 0 ))
        {
          fft_noise_floor[_i] = fft_frequency_magnitude_db[_channel][fft_frequency_magnitude_db_index][_i];
        }
      }

      // perform average calculation for this channel and magnitude index
      fft_frequency_magnitude_db_average[_channel][_i] = fft_frequency_magnitude_db[_channel][0][_i];

      for ( int sample_index = 1; sample_index < FFT_AVERAGE_SAMPLES; sample_index++ )
      {

        fft_frequency_magnitude_db_average[_channel][_i] += fft_frequency_magnitude_db[_channel][sample_index][_i];
      }

      fft_frequency_magnitude_db_average[_channel][_i] /= (float)FFT_AVERAGE_SAMPLES;
#else
      fft_frequency_magnitude_db[_channel][freqpoint]
                = (20.0f * log10f(complexABS(fft_out_buffer[_channel][_i], fft_out_buffer[_channel][_i+1])));// - offset;
#endif
    }
  }

  // increment noise_floor_samples counter outside of channel loop
  if ( noise_floor_samples < FFT_REQUIRED_NOISE_FLOOR_SAMPLES )
  {
    noise_floor_samples++;
  }

  // increment fft buffer index for next iteration

  fft_frequency_magnitude_db_index = ( fft_frequency_magnitude_db_index + 1 ) % FFT_AVERAGE_SAMPLES;

}

static void anomalyDetectionLogic( void )
{
  /*  Each channel has a counter for each fft magnitude bin, this function compares the
   *  magnitude of each bin to the associated noise floor bin + offset.
   *  If the channel magnitude is equal to or larger than the noise floor + offset, then that bin
   *  counter is incremented, up to a max bound.
   *  Else: the bin counter is decremented, unless it is already zero
   *
   *  Anomaly detect includes hysteresis for each bin
   *
   *  during these loops, the signal magnitudes for each microphone are also determined,
   *  where the magnitude is defined as the largest value for fft magnitude relative to the trigger
   *  threshold for each bin
   */

  // TODO - disregard invalid/fault state channels
  //if(!RUN_ONCE) printf("In perform anomalyDetectionLogic\r\n");
  float _largest_magnitude_db;
  uint16_t _largest_magnitude_bin = 0;
  boolean_t _channel_active;
  boolean_t _anomaly_detected = FALSE;

  // for each channel
  for ( int channel = 0; channel < (ADC1_CHANNELS + ADC3_CHANNELS); channel++ )
  {
    _largest_magnitude_db = -200.0f;
    _channel_active = FALSE;

    // for each ultrasonic bin
    for ( int bin_index = 0; bin_index < FFT_SPECTRUM_NUMBER_OF_ULTRASONIC_BINS; bin_index++ )
    {
      // save bin and magnitude of bin with largest magnitude relative to the
      if ( (fft_frequency_magnitude_db_average[channel][bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
             - (fft_noise_floor[bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
                  + fft_trigger_threshold_offset_db))
                      > _largest_magnitude_db )
      {
        _largest_magnitude_db = fft_frequency_magnitude_db_average[channel][bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
                             - (fft_noise_floor[bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
                                    + fft_trigger_threshold_offset_db);

        _largest_magnitude_bin = bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW;
      }

      // check if above detection threshold, (noise floor + offset)
      if ( fft_frequency_magnitude_db_average[channel][bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
                >= ( fft_noise_floor[bin_index + FFT_SPECTRUM_ULTRASONIC_BIN_INDEX_LOW]
                         + fft_trigger_threshold_offset_db ))
      {
        // if above detection threshold, increment, up to max count limit
        fft_magnitude_trigger_counter[channel][bin_index] = ((fft_magnitude_trigger_counter[channel][bin_index] & FFT_DETECT_COUNT_MASK)
                                                                == FFT_DETECT_THRESHOLD_MAX_COUNT
                                                             ? FFT_DETECT_THRESHOLD_MAX_COUNT
                                                               : (fft_magnitude_trigger_counter[channel][bin_index] + 1));
      }
      else
      {
        // if below detection threshold, decrement, minimum 0
        fft_magnitude_trigger_counter[channel][bin_index] = ((fft_magnitude_trigger_counter[channel][bin_index] & FFT_DETECT_COUNT_MASK)
                                                                == 0
                                                            ? 0 : (fft_magnitude_trigger_counter[channel][bin_index] - 1));
      }

      // determine active anomaly state of this bin, set bin detect state flag
      if ( fft_magnitude_trigger_counter[channel][bin_index] >= FFT_DETECT_THRESHOLD_RISING_COUNT )
      {
        fft_magnitude_trigger_counter[channel][bin_index] |= FFT_DETECT_BIN_ACTIVE_FLAG;
      }
      else if ( fft_magnitude_trigger_counter[channel][bin_index] < FFT_DETECT_THRESHOLD_FALLING_COUNT )
      {
        fft_magnitude_trigger_counter[channel][bin_index] &= ~FFT_DETECT_BIN_ACTIVE_FLAG;
      }

      // determine active anomaly state of this channel
      if ( fft_magnitude_trigger_counter[channel][bin_index] & FFT_DETECT_BIN_ACTIVE_FLAG )
      {
        _channel_active = TRUE;
        _anomaly_detected = TRUE;
      }
    }

    // update ultrasonic POIs for this channel
    channel_is_active_anomaly[channel] = _channel_active;
    fft_channel_magnitude_db[channel] = _largest_magnitude_db;
    fft_channel_magnitude_bin[channel] = _largest_magnitude_bin;
  }

  // increment previous/current detect state
  anomaly_detect_state_previous = anomaly_detect_state_current;
  anomaly_detect_state_current = _anomaly_detected;

  setUserLED2State( anomaly_detect_state_current );
}

// Determines characteristics of an active anomaly, default values if none
// Only capable of generating one set of values, does not handle multiple anomalies
static void anomalyUpdateCharacteristics( void )
{
  // Anomaly frequency, ** just potato averaging of active microphone frequencies **
  //if(!RUN_ONCE) printf("In perform anomalyUpdateCharacteristics\r\n");
  float _sum = 0.0f;
  uint8_t _active_channels = 0;

  // sum of frequencies of active channels
  for ( int _channel = 0; _channel < NUM_MICROPHONE_CHANNELS; _channel++ )
  {
    if ( channel_is_active_anomaly[_channel] )
    {
      _sum += (float)fft_channel_magnitude_bin[_channel] * ADC_SAMPLE_FREQUENCY / (FFT_BATCH_SIZE);
      _active_channels++;
    }
  }

  // if none active, default frequency
  if ( _active_channels == 0 )
  {
    anomaly_frequency = 20000.0f;
  }

  anomaly_frequency = _sum / _active_channels;

  // normalized frequency
  anomaly_frequency_normalized = (anomaly_frequency - 20000.0f) / (120000.0f - 20000.0f);

  // magnitude, ** also potato but functional **
  float _largest = -200.0f;

  for ( int _channel = 0; _channel < NUM_MICROPHONE_CHANNELS; _channel++ )
  {
    if (( fft_channel_magnitude_db[_channel] > _largest )
        && ( channel_is_active_anomaly[_channel] ))
    {
      _largest = fft_channel_magnitude_db[_channel];
    }
  }

  anomaly_magnitude = _largest;

  // update inter-processor communication (shared RAM region)
  IPCSetAnomalyDetectState( anomaly_detect_state_current );
  IPCSetAnomalyFrequency( anomaly_frequency );
  IPCSetAnomalyMagnitudedB( anomaly_magnitude );
}
